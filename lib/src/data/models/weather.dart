class GetWeatherResponse {
  final double lat;
  final double lon;
  final String timezone;
  final int timezoneOffset;
  final CurrentResponse current;
  final List<MinutelyResponse> minutely;
  final List<HourlyResponse> hourly;
  final List<DailyResponse> daily;
  final List<AlertsResponse> alerts;

  const GetWeatherResponse({
    required this.lat,
    required this.lon,
    required this.timezone,
    required this.timezoneOffset,
    required this.current,
    required this.minutely,
    required this.hourly,
    required this.daily,
    required this.alerts,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GetWeatherResponse &&
          runtimeType == other.runtimeType &&
          lat == other.lat &&
          lon == other.lon &&
          timezone == other.timezone &&
          timezoneOffset == other.timezoneOffset &&
          current == other.current &&
          minutely == other.minutely &&
          hourly == other.hourly &&
          daily == other.daily &&
          alerts == other.alerts);

  @override
  int get hashCode =>
      lat.hashCode ^
      lon.hashCode ^
      timezone.hashCode ^
      timezoneOffset.hashCode ^
      current.hashCode ^
      minutely.hashCode ^
      hourly.hashCode ^
      daily.hashCode ^
      alerts.hashCode;

  @override
  String toString() {
    return 'Autogenerated{' +
        ' lat: $lat,' +
        ' lon: $lon,' +
        ' timezone: $timezone,' +
        ' timezoneOffset: $timezoneOffset,' +
        ' current: $current,' +
        ' minutely: $minutely,' +
        ' hourly: $hourly,' +
        ' daily: $daily,' +
        ' alerts: $alerts,' +
        '}';
  }

  GetWeatherResponse copyWith({
    double? lat,
    double? lon,
    String? timezone,
    int? timezoneOffset,
    CurrentResponse? current,
    List<MinutelyResponse>? minutely,
    List<HourlyResponse>? hourly,
    List<DailyResponse>? daily,
    List<AlertsResponse>? alerts,
  }) {
    return GetWeatherResponse(
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      timezone: timezone ?? this.timezone,
      timezoneOffset: timezoneOffset ?? this.timezoneOffset,
      current: current ?? this.current,
      minutely: minutely ?? this.minutely,
      hourly: hourly ?? this.hourly,
      daily: daily ?? this.daily,
      alerts: alerts ?? this.alerts,
    );
  }

  factory GetWeatherResponse.fromMap(Map<String, dynamic> map) {
    return GetWeatherResponse(
      lat: double.parse(map['lat'].toString()),
      lon: double.parse(map['lon'].toString()),
      timezone: map['timezone'] as String,
      timezoneOffset: map['timezone_offset'] as int,
      current: CurrentResponse.fromMap(map['current']),
      minutely: listConverter<MinutelyResponse>(map["minutely"], (d) => MinutelyResponse.fromMap(d)),
      hourly: listConverter<HourlyResponse>(map["hourly"], (d) => HourlyResponse.fromMap(d)),
      daily: listConverter<DailyResponse>(map["daily"], (d) => DailyResponse.fromMap(d)),
      alerts: listConverter<AlertsResponse>(map["alerts"], (d) => AlertsResponse.fromMap(d)),
    );
  }
}

class CurrentResponse {
  final int dt;
  final int sunrise;
  final int sunset;
  final double temp;
  final double feelsLike;
  final int pressure;
  final int humidity;
  final double dewPoint;
  final double uvi;
  final int clouds;
  final int visibility;
  final double windSpeed;
  final int windDeg;
  final double? windGust;
  final double? rain;
  final double? snow;
  final List<WeatherResponse> weather;

//<editor-fold desc="Data Methods">

  const CurrentResponse({
    required this.dt,
    required this.sunrise,
    required this.sunset,
    required this.temp,
    required this.feelsLike,
    required this.pressure,
    required this.humidity,
    required this.dewPoint,
    required this.uvi,
    required this.clouds,
    required this.visibility,
    required this.windSpeed,
    required this.windDeg,
    this.windGust,
    this.rain,
    this.snow,
    required this.weather,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CurrentResponse &&
          runtimeType == other.runtimeType &&
          dt == other.dt &&
          sunrise == other.sunrise &&
          sunset == other.sunset &&
          temp == other.temp &&
          feelsLike == other.feelsLike &&
          pressure == other.pressure &&
          humidity == other.humidity &&
          dewPoint == other.dewPoint &&
          uvi == other.uvi &&
          clouds == other.clouds &&
          visibility == other.visibility &&
          windSpeed == other.windSpeed &&
          windDeg == other.windDeg &&
          windGust == other.windGust &&
          rain == other.rain &&
          snow == other.snow &&
          weather == other.weather);

  @override
  int get hashCode =>
      dt.hashCode ^
      sunrise.hashCode ^
      sunset.hashCode ^
      temp.hashCode ^
      feelsLike.hashCode ^
      pressure.hashCode ^
      humidity.hashCode ^
      dewPoint.hashCode ^
      uvi.hashCode ^
      clouds.hashCode ^
      visibility.hashCode ^
      windSpeed.hashCode ^
      windDeg.hashCode ^
      windGust.hashCode ^
      rain.hashCode ^
      snow.hashCode ^
      weather.hashCode;

  @override
  String toString() {
    return 'CurrentResponse{' +
        ' dt: $dt,' +
        ' sunrise: $sunrise,' +
        ' sunset: $sunset,' +
        ' temp: $temp,' +
        ' feelsLike: $feelsLike,' +
        ' pressure: $pressure,' +
        ' humidity: $humidity,' +
        ' dewPoint: $dewPoint,' +
        ' uvi: $uvi,' +
        ' clouds: $clouds,' +
        ' visibility: $visibility,' +
        ' windSpeed: $windSpeed,' +
        ' windDeg: $windDeg,' +
        ' windGust: $windGust,' +
        ' rain: $rain,' +
        ' snow: $snow,' +
        ' weather: $weather,' +
        '}';
  }

  CurrentResponse copyWith({
    int? dt,
    int? sunrise,
    int? sunset,
    double? temp,
    double? feelsLike,
    int? pressure,
    int? humidity,
    double? dewPoint,
    double? uvi,
    int? clouds,
    int? visibility,
    double? windSpeed,
    int? windDeg,
    double? windGust,
    double? rain,
    double? snow,
    List<WeatherResponse>? weather,
  }) {
    return CurrentResponse(
      dt: dt ?? this.dt,
      sunrise: sunrise ?? this.sunrise,
      sunset: sunset ?? this.sunset,
      temp: temp ?? this.temp,
      feelsLike: feelsLike ?? this.feelsLike,
      pressure: pressure ?? this.pressure,
      humidity: humidity ?? this.humidity,
      dewPoint: dewPoint ?? this.dewPoint,
      uvi: uvi ?? this.uvi,
      clouds: clouds ?? this.clouds,
      visibility: visibility ?? this.visibility,
      windSpeed: windSpeed ?? this.windSpeed,
      windDeg: windDeg ?? this.windDeg,
      windGust: windGust ?? this.windGust,
      rain: rain ?? this.rain,
      snow: snow ?? this.snow,
      weather: weather ?? this.weather,
    );
  }



  factory CurrentResponse.fromMap(Map<String, dynamic> map) {
    return CurrentResponse(
      dt: map['dt'] as int,
      sunrise: map['sunrise'] as int,
      sunset: map['sunset'] as int,
      temp: double.parse(map['temp'].toString()),
      feelsLike: double.parse(map['feels_like'].toString()),
      pressure: map['pressure'] as int,
      humidity: map['humidity'] as int,
      dewPoint: double.parse(map['dew_point'].toString()),
      uvi: map['uvi'] as double,
      clouds: map['clouds'] as int,
      visibility: map['visibility'] as int,
      windSpeed: double.parse(map['wind_speed'].toString()),
      windDeg: map['wind_deg'] as int,
      windGust:  map['wind_gust'] == null ? null : double.parse(map['wind_gust'].toString()),
      rain: map['rain'] == null ? null : double.parse(map['rain'].toString()),
      snow: map['snow'] == null ? null : double.parse(map['snow'].toString()),
      weather: listConverter<WeatherResponse>(map["weather"], (d) => WeatherResponse.fromMap(d)),
    );
  }
}

class MinutelyResponse {
  final int dt;
  final int precipitation;

  const MinutelyResponse({
    required this.dt,
    required this.precipitation,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MinutelyResponse &&
          runtimeType == other.runtimeType &&
          dt == other.dt &&
          precipitation == other.precipitation);

  @override
  int get hashCode => dt.hashCode ^ precipitation.hashCode;

  @override
  String toString() {
    return 'Minutely{' + ' dt: $dt,' + ' precipitation: $precipitation,' + '}';
  }

  MinutelyResponse copyWith({
    int? dt,
    int? precipitation,
  }) {
    return MinutelyResponse(
      dt: dt ?? this.dt,
      precipitation: precipitation ?? this.precipitation,
    );
  }

  factory MinutelyResponse.fromMap(Map<String, dynamic> map) {
    return MinutelyResponse(
      dt: map['dt'] as int,
      precipitation: map['precipitation'] as int,
    );
  }
}

class HourlyResponse {
  final int dt;
  final double temp;
  final double feelsLike;
  final int pressure;
  final int humidity;
  final double dewPoint;
  final double uvi;
  final int clouds;
  final int visibility;
  final double windSpeed;
  final int windDeg;
  final double? windGust;
  final double? rain;
  final double? snow;
  final List<WeatherResponse> weather;
  final int pop;

//<editor-fold desc="Data Methods">

  const HourlyResponse({
    required this.dt,
    required this.temp,
    required this.feelsLike,
    required this.pressure,
    required this.humidity,
    required this.dewPoint,
    required this.uvi,
    required this.clouds,
    required this.visibility,
    required this.windSpeed,
    required this.windDeg,
    this.windGust,
    this.rain,
    this.snow,
    required this.weather,
    required this.pop,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is HourlyResponse &&
          runtimeType == other.runtimeType &&
          dt == other.dt &&
          temp == other.temp &&
          feelsLike == other.feelsLike &&
          pressure == other.pressure &&
          humidity == other.humidity &&
          dewPoint == other.dewPoint &&
          uvi == other.uvi &&
          clouds == other.clouds &&
          visibility == other.visibility &&
          windSpeed == other.windSpeed &&
          windDeg == other.windDeg &&
          windGust == other.windGust &&
          rain == other.rain &&
          snow == other.snow &&
          weather == other.weather &&
          pop == other.pop);

  @override
  int get hashCode =>
      dt.hashCode ^
      temp.hashCode ^
      feelsLike.hashCode ^
      pressure.hashCode ^
      humidity.hashCode ^
      dewPoint.hashCode ^
      uvi.hashCode ^
      clouds.hashCode ^
      visibility.hashCode ^
      windSpeed.hashCode ^
      windDeg.hashCode ^
      windGust.hashCode ^
      rain.hashCode ^
      snow.hashCode ^
      weather.hashCode ^
      pop.hashCode;

  @override
  String toString() {
    return 'HourlyResponse{' +
        ' dt: $dt,' +
        ' temp: $temp,' +
        ' feelsLike: $feelsLike,' +
        ' pressure: $pressure,' +
        ' humidity: $humidity,' +
        ' dewPoint: $dewPoint,' +
        ' uvi: $uvi,' +
        ' clouds: $clouds,' +
        ' visibility: $visibility,' +
        ' windSpeed: $windSpeed,' +
        ' windDeg: $windDeg,' +
        ' windGust: $windGust,' +
        ' rain: $rain,' +
        ' snow: $snow,' +
        ' weather: $weather,' +
        ' pop: $pop,' +
        '}';
  }

  HourlyResponse copyWith({
    int? dt,
    double? temp,
    double? feelsLike,
    int? pressure,
    int? humidity,
    double? dewPoint,
    double? uvi,
    int? clouds,
    int? visibility,
    double? windSpeed,
    int? windDeg,
    double? windGust,
    double? rain,
    double? snow,
    List<WeatherResponse>? weather,
    int? pop,
  }) {
    return HourlyResponse(
      dt: dt ?? this.dt,
      temp: temp ?? this.temp,
      feelsLike: feelsLike ?? this.feelsLike,
      pressure: pressure ?? this.pressure,
      humidity: humidity ?? this.humidity,
      dewPoint: dewPoint ?? this.dewPoint,
      uvi: uvi ?? this.uvi,
      clouds: clouds ?? this.clouds,
      visibility: visibility ?? this.visibility,
      windSpeed: windSpeed ?? this.windSpeed,
      windDeg: windDeg ?? this.windDeg,
      windGust: windGust ?? this.windGust,
      rain: rain ?? this.rain,
      snow: snow ?? this.snow,
      weather: weather ?? this.weather,
      pop: pop ?? this.pop,
    );
  }


  factory HourlyResponse.fromMap(Map<String, dynamic> map) {
    return HourlyResponse(
      dt: map['dt'] as int,
      temp: double.parse(map['temp'].toString()),
      feelsLike: double.parse(map['feels_like'].toString()),
      pressure: map['pressure'] as int,
      humidity: map['humidity'] as int,
      dewPoint: double.parse(map['dew_point'].toString()),
      uvi: double.parse(map['uvi'].toString()),
      clouds: map['clouds'] as int,
      visibility: map['visibility'] as int,
      windSpeed: double.parse(map['wind_speed'].toString()),
      windDeg: map['wind_deg'] as int,
      windGust:  map['wind_gust'] == null ? null : double.parse(map['wind_gust'].toString()),
      rain: map['rain'] == null ? null : double.parse(map['rain'].toString()),
      snow: map['snow'] == null ? null : double.parse(map['snow'].toString()),
      weather: listConverter<WeatherResponse>(map["weather"], (d) => WeatherResponse.fromMap(d)),
      pop: map['pop'] as int,
    );
  }

}

class DailyResponse {
  final int dt;
  final int sunrise;
  final int sunset;
  final int moonrise;
  final int moonset;
  final double moonPhase;
  final TempResponse temp;
  final FeelsLikeResponse feelsLike;
  final int pressure;
  final int humidity;
  final double dewPoint;
  final double windSpeed;
  final int windDeg;
  final double? windGust;
  final List<WeatherResponse> weather;
  final int clouds;
  final double pop;
  final double uvi;
  final double? rain;
  final double? snow;

//<editor-fold desc="Data Methods">

  const DailyResponse({
    required this.dt,
    required this.sunrise,
    required this.sunset,
    required this.moonrise,
    required this.moonset,
    required this.moonPhase,
    required this.temp,
    required this.feelsLike,
    required this.pressure,
    required this.humidity,
    required this.dewPoint,
    required this.windSpeed,
    required this.windDeg,
    this.windGust,
    required this.weather,
    required this.clouds,
    required this.pop,
    required this.uvi,
    this.rain,
    this.snow,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DailyResponse &&
          runtimeType == other.runtimeType &&
          dt == other.dt &&
          sunrise == other.sunrise &&
          sunset == other.sunset &&
          moonrise == other.moonrise &&
          moonset == other.moonset &&
          moonPhase == other.moonPhase &&
          temp == other.temp &&
          feelsLike == other.feelsLike &&
          pressure == other.pressure &&
          humidity == other.humidity &&
          dewPoint == other.dewPoint &&
          windSpeed == other.windSpeed &&
          windDeg == other.windDeg &&
          windGust == other.windGust &&
          weather == other.weather &&
          clouds == other.clouds &&
          pop == other.pop &&
          uvi == other.uvi &&
          rain == other.rain &&
          snow == other.snow);

  @override
  int get hashCode =>
      dt.hashCode ^
      sunrise.hashCode ^
      sunset.hashCode ^
      moonrise.hashCode ^
      moonset.hashCode ^
      moonPhase.hashCode ^
      temp.hashCode ^
      feelsLike.hashCode ^
      pressure.hashCode ^
      humidity.hashCode ^
      dewPoint.hashCode ^
      windSpeed.hashCode ^
      windDeg.hashCode ^
      windGust.hashCode ^
      weather.hashCode ^
      clouds.hashCode ^
      pop.hashCode ^
      uvi.hashCode ^
      rain.hashCode ^
      snow.hashCode;

  @override
  String toString() {
    return 'DailyResponse{' +
        ' dt: $dt,' +
        ' sunrise: $sunrise,' +
        ' sunset: $sunset,' +
        ' moonrise: $moonrise,' +
        ' moonset: $moonset,' +
        ' moonPhase: $moonPhase,' +
        ' temp: $temp,' +
        ' feelsLike: $feelsLike,' +
        ' pressure: $pressure,' +
        ' humidity: $humidity,' +
        ' dewPoint: $dewPoint,' +
        ' windSpeed: $windSpeed,' +
        ' windDeg: $windDeg,' +
        ' windGust: $windGust,' +
        ' weather: $weather,' +
        ' clouds: $clouds,' +
        ' pop: $pop,' +
        ' uvi: $uvi,' +
        ' rain: $rain,' +
        ' snow: $snow,' +
        '}';
  }

  DailyResponse copyWith({
    int? dt,
    int? sunrise,
    int? sunset,
    int? moonrise,
    int? moonset,
    double? moonPhase,
    TempResponse? temp,
    FeelsLikeResponse? feelsLike,
    int? pressure,
    int? humidity,
    double? dewPoint,
    double? windSpeed,
    int? windDeg,
    double? windGust,
    List<WeatherResponse>? weather,
    int? clouds,
    double? pop,
    double? uvi,
    double? rain,
    double? snow,
  }) {
    return DailyResponse(
      dt: dt ?? this.dt,
      sunrise: sunrise ?? this.sunrise,
      sunset: sunset ?? this.sunset,
      moonrise: moonrise ?? this.moonrise,
      moonset: moonset ?? this.moonset,
      moonPhase: moonPhase ?? this.moonPhase,
      temp: temp ?? this.temp,
      feelsLike: feelsLike ?? this.feelsLike,
      pressure: pressure ?? this.pressure,
      humidity: humidity ?? this.humidity,
      dewPoint: dewPoint ?? this.dewPoint,
      windSpeed: windSpeed ?? this.windSpeed,
      windDeg: windDeg ?? this.windDeg,
      windGust: windGust ?? this.windGust,
      weather: weather ?? this.weather,
      clouds: clouds ?? this.clouds,
      pop: pop ?? this.pop,
      uvi: uvi ?? this.uvi,
      rain: rain ?? this.rain,
      snow: snow ?? this.snow,
    );
  }

  factory DailyResponse.fromMap(Map<String, dynamic> map) {
    return DailyResponse(
      dt: map['dt'] as int,
      sunrise: map['sunrise'] as int,
      sunset: map['sunset'] as int,
      moonrise: map['moonrise'] as int,
      moonset: map['moonset'] as int,
      moonPhase: double.parse(map['moon_phase'].toString()),
      temp: TempResponse.fromMap(map['temp']),
      feelsLike: FeelsLikeResponse.fromMap(map['feels_like']),
      pressure: map['pressure'] as int,
      humidity: map['humidity'] as int,
      dewPoint: double.parse(map['dew_point'].toString()),
      windSpeed: double.parse(map['wind_speed'].toString()),
      windDeg: map['wind_deg'] as int,
      weather: listConverter<WeatherResponse>(map["weather"], (d) => WeatherResponse.fromMap(d)),
      clouds: map['clouds'] as int,
      pop: double.parse(map['pop'].toString()),
      uvi: double.parse(map['uvi'].toString()),
      windGust:  map['wind_gust'] == null ? null : double.parse(map['wind_gust'].toString()),
      rain: map['rain'] == null ? null : double.parse(map['rain'].toString()),
      snow: map['snow'] == null ? null : double.parse(map['snow'].toString()),
    );
  }

}

class AlertsResponse {
  final String senderName;
  final String event;
  final int start;
  final int end;
  final String description;
  final List<String> tags;

  const AlertsResponse({
    required this.senderName,
    required this.event,
    required this.start,
    required this.end,
    required this.description,
    required this.tags,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AlertsResponse &&
          runtimeType == other.runtimeType &&
          senderName == other.senderName &&
          event == other.event &&
          start == other.start &&
          end == other.end &&
          description == other.description &&
          tags == other.tags);

  @override
  int get hashCode =>
      senderName.hashCode ^
      event.hashCode ^
      start.hashCode ^
      end.hashCode ^
      description.hashCode ^
      tags.hashCode;

  @override
  String toString() {
    return 'Alerts{' +
        ' senderName: $senderName,' +
        ' event: $event,' +
        ' start: $start,' +
        ' end: $end,' +
        ' description: $description,' +
        ' tags: $tags,' +
        '}';
  }

  AlertsResponse copyWith({
    String? senderName,
    String? event,
    int? start,
    int? end,
    String? description,
    List<String>? tags,
  }) {
    return AlertsResponse(
      senderName: senderName ?? this.senderName,
      event: event ?? this.event,
      start: start ?? this.start,
      end: end ?? this.end,
      description: description ?? this.description,
      tags: tags ?? this.tags,
    );
  }

  factory AlertsResponse.fromMap(Map<String, dynamic> map) {
    return AlertsResponse(
      senderName: map['sender_name'] as String,
      event: map['event'] as String,
      start: map['start'] as int,
      end: map['end'] as int,
      description: map['description'] as String,
      tags: (map['tags'] as List).map<String>((e) => e).toList(),
    );
  }
}

class WeatherResponse {
  final int id;
  final String main;
  final String description;
  final String icon;

  const WeatherResponse({
    required this.id,
    required this.main,
    required this.description,
    required this.icon,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WeatherResponse &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          main == other.main &&
          description == other.description &&
          icon == other.icon);

  @override
  int get hashCode => id.hashCode ^ main.hashCode ^ description.hashCode ^ icon.hashCode;

  @override
  String toString() {
    return 'Weather{' + ' id: $id,' + ' main: $main,' + ' description: $description,' + ' icon: $icon,' + '}';
  }

  WeatherResponse copyWith({
    int? id,
    String? main,
    String? description,
    String? icon,
  }) {
    return WeatherResponse(
      id: id ?? this.id,
      main: main ?? this.main,
      description: description ?? this.description,
      icon: icon ?? this.icon,
    );
  }

  factory WeatherResponse.fromMap(Map<String, dynamic> map) {
    return WeatherResponse(
      id: map['id'] as int,
      main: map['main'] as String,
      description: map['description'] as String,
      icon: map['icon'] as String,
    );
  }
}

class TempResponse {
  final double day;
  final double min;
  final double max;
  final double night;
  final double eve;
  final double morn;

  const TempResponse({
    required this.day,
    required this.min,
    required this.max,
    required this.night,
    required this.eve,
    required this.morn,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TempResponse &&
          runtimeType == other.runtimeType &&
          day == other.day &&
          min == other.min &&
          max == other.max &&
          night == other.night &&
          eve == other.eve &&
          morn == other.morn);

  @override
  int get hashCode =>
      day.hashCode ^ min.hashCode ^ max.hashCode ^ night.hashCode ^ eve.hashCode ^ morn.hashCode;

  @override
  String toString() {
    return 'Temp{' +
        ' day: $day,' +
        ' min: $min,' +
        ' max: $max,' +
        ' night: $night,' +
        ' eve: $eve,' +
        ' morn: $morn,' +
        '}';
  }

  TempResponse copyWith({
    double? day,
    double? min,
    double? max,
    double? night,
    double? eve,
    double? morn,
  }) {
    return TempResponse(
      day: day ?? this.day,
      min: min ?? this.min,
      max: max ?? this.max,
      night: night ?? this.night,
      eve: eve ?? this.eve,
      morn: morn ?? this.morn,
    );
  }

  factory TempResponse.fromMap(Map<String, dynamic> map) {
    return TempResponse(
      day: double.parse(map['day'].toString()),
      min: double.parse(map['min'].toString()),
      max: double.parse(map['max'].toString()),
      night: double.parse(map['night'].toString()),
      eve: double.parse(map['eve'].toString()),
      morn: double.parse(map['morn'].toString()),
    );
  }
}

class FeelsLikeResponse {
  final double day;
  final double night;
  final double eve;
  final double morn;

  const FeelsLikeResponse({
    required this.day,
    required this.night,
    required this.eve,
    required this.morn,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FeelsLikeResponse &&
          runtimeType == other.runtimeType &&
          day == other.day &&
          night == other.night &&
          eve == other.eve &&
          morn == other.morn);

  @override
  int get hashCode => day.hashCode ^ night.hashCode ^ eve.hashCode ^ morn.hashCode;

  @override
  String toString() {
    return 'FeelsLike{' + ' day: $day,' + ' night: $night,' + ' eve: $eve,' + ' morn: $morn,' + '}';
  }

  FeelsLikeResponse copyWith({
    double? day,
    double? night,
    double? eve,
    double? morn,
  }) {
    return FeelsLikeResponse(
      day: day ?? this.day,
      night: night ?? this.night,
      eve: eve ?? this.eve,
      morn: morn ?? this.morn,
    );
  }

  factory FeelsLikeResponse.fromMap(Map<String, dynamic> map) {
    return FeelsLikeResponse(
      day: double.parse(map['day'].toString()),
      night: double.parse(map['night'].toString()),
      eve: double.parse(map['eve'].toString()),
      morn: double.parse(map['morn'].toString()),
    );
  }
}

List<T> listConverter<T>(dynamic o, Function(Map<String, dynamic>) parser) =>
    (o as List).map<T>((e) => parser(e)).toList();//TODO in utils
